import pkg from 'pg';
const { Pool } = pkg;
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';

const execPromise = promisify(exec);

const pool = new Pool({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'nutriplan',
  user: process.env.DB_USER || process.env.USER,
  password: process.env.DB_PASSWORD || '',
});

const BACKUP_DIR = path.join(process.cwd(), 'backups');
const BACKUP_RETENTION_HOURS = 48;

// CreeazƒÉ directorul de backups dacƒÉ nu existƒÉ
async function ensureBackupDir() {
  try {
    await fs.access(BACKUP_DIR);
  } catch {
    await fs.mkdir(BACKUP_DIR, { recursive: true });
  }
}

// CreeazƒÉ backup complet al bazei de date
export async function createBackup(userId = null, autoGenerated = false) {
  await ensureBackupDir();
  
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const filename = `nutriplan_backup_${timestamp}.sql`;
  const filePath = path.join(BACKUP_DIR, filename);
  
  try {
    // pg_dump pentru a crea backup-ul
    const dbName = process.env.DB_NAME || 'nutriplan';
    const dbUser = process.env.DB_USER || process.env.USER;
    
    // √éncearcƒÉ sƒÉ gƒÉseascƒÉ pg_dump 16 (versiunea corectƒÉ pentru PostgreSQL 16)
    const pgDumpPath = process.env.PG_DUMP_PATH || '/opt/homebrew/opt/postgresql@16/bin/pg_dump';
    
    const command = `${pgDumpPath} -U ${dbUser} -d ${dbName} -f "${filePath}" --no-owner --no-acl`;
    
    await execPromise(command);
    
    // Calculez mƒÉrimea fi»ôierului
    const stats = await fs.stat(filePath);
    const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
    
    // Salvez √Æn DB
    const client = await pool.connect();
    try {
      const result = await client.query(`
        INSERT INTO backups (filename, file_path, size_mb, created_by, auto_generated, tables_included)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING *
      `, [
        filename,
        filePath,
        sizeMB,
        userId,
        autoGenerated,
        ['users', 'recipes', 'daily_checkins', 'weight_entries', 'progress_notes', 'friendships', 'messages']
      ]);
      
      console.log(`‚úÖ Backup creat: ${filename} (${sizeMB} MB)`);
      return result.rows[0];
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('‚ùå Eroare la crearea backup:', error);
    throw error;
  }
}

// »òterge backup-uri mai vechi de 48h
export async function cleanupOldBackups() {
  const client = await pool.connect();
  
  try {
    // GƒÉse»ôte backup-uri mai vechi de 48h
    const result = await client.query(`
      SELECT id, filename, file_path 
      FROM backups 
      WHERE created_at < NOW() - INTERVAL '${BACKUP_RETENTION_HOURS} hours'
      AND auto_generated = true
    `);
    
    for (const backup of result.rows) {
      try {
        // »òterge fi»ôierul fizic
        await fs.unlink(backup.file_path);
        
        // »òterge din DB
        await client.query('DELETE FROM backups WHERE id = $1', [backup.id]);
        
        console.log(`üóëÔ∏è Backup »ôters (>48h): ${backup.filename}`);
      } catch (error) {
        console.error(`‚ö†Ô∏è Nu pot »ôterge ${backup.filename}:`, error.message);
      }
    }
    
    return result.rows.length;
  } finally {
    client.release();
  }
}

// ListeazƒÉ toate backup-urile
export async function listBackups() {
  const client = await pool.connect();
  
  try {
    const result = await client.query(`
      SELECT b.*, u.name as created_by_name, u.email as created_by_email
      FROM backups b
      LEFT JOIN users u ON b.created_by = u.id
      ORDER BY b.created_at DESC
    `);
    
    return result.rows;
  } finally {
    client.release();
  }
}

// »òterge un backup specific
export async function deleteBackup(backupId) {
  const client = await pool.connect();
  
  try {
    const result = await client.query('SELECT file_path FROM backups WHERE id = $1', [backupId]);
    
    if (result.rows.length === 0) {
      throw new Error('Backup not found');
    }
    
    const filePath = result.rows[0].file_path;
    
    // »òterge fi»ôierul fizic
    try {
      await fs.unlink(filePath);
    } catch (error) {
      console.warn('Fi»ôier deja »ôters:', filePath);
    }
    
    // »òterge din DB
    await client.query('DELETE FROM backups WHERE id = $1', [backupId]);
    
    console.log(`‚úÖ Backup »ôters: ID ${backupId}`);
    return true;
  } finally {
    client.release();
  }
}

// Restabile»ôte din backup
export async function restoreBackup(backupId) {
  const client = await pool.connect();
  
  try {
    const result = await client.query('SELECT file_path FROM backups WHERE id = $1', [backupId]);
    
    if (result.rows.length === 0) {
      throw new Error('Backup not found');
    }
    
    const filePath = result.rows[0].file_path;
    const dbName = process.env.DB_NAME || 'nutriplan';
    const dbUser = process.env.DB_USER || process.env.USER;
    
    // RestaureazƒÉ backup-ul
    const command = `psql -U ${dbUser} -d ${dbName} -f "${filePath}"`;
    
    await execPromise(command);
    
    console.log(`‚úÖ Backup restabilit: ID ${backupId}`);
    return true;
  } finally {
    client.release();
  }
}

// Porne»ôte cron job pentru backup automat (la fiecare 12 ore)
export function startAutomaticBackups() {
  const BACKUP_INTERVAL = 12 * 60 * 60 * 1000; // 12 ore √Æn milisecunde
  
  // CreeazƒÉ primul backup imediat
  console.log('üîÑ Pornesc sistemul de backup automat...');
  createBackup(null, true).catch(console.error);
  
  // Cleanup backups vechi la fiecare orƒÉ
  setInterval(() => {
    cleanupOldBackups().then(count => {
      if (count > 0) {
        console.log(`üóëÔ∏è Cleanup: ${count} backup-uri vechi »ôterse`);
      }
    }).catch(console.error);
  }, 60 * 60 * 1000); // La fiecare orƒÉ
  
  // CreeazƒÉ backup automat la interval
  setInterval(() => {
    createBackup(null, true).catch(console.error);
  }, BACKUP_INTERVAL);
  
  console.log(`‚úÖ Backup automat activat: la fiecare ${BACKUP_INTERVAL / (60 * 60 * 1000)} ore`);
  console.log(`‚úÖ Cleanup automat: backup-uri > ${BACKUP_RETENTION_HOURS}h vor fi »ôterse`);
}

